<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Evolu√ß√£o Financeira Mensal</title>
    <script src="https://cdn.plot.ly/plotly-2.31.1.min.js"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f4f7f9;
            margin: 0;
            padding: 20px;
        }
        .container {
            max-width: 1000px;
            margin: 0 auto;
            background-color: #ffffff;
            border-radius: 12px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            padding: 20px;
        }
        h1 {
            text-align: center;
            color: #1e3a8a;
            font-size: 1.5rem;
            margin-bottom: 20px;
        }
        #grafico-evolucao-mensal {
            height: 500px; /* Altura padr√£o para o gr√°fico */
            width: 100%;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üìà Evolu√ß√£o de Gastos e Receitas Mensais</h1>
        <div id="grafico-evolucao-mensal">
            </div>
    </div>

    <script>
        // --- VARI√ÅVEIS DE ESTADO E CONSTANTES MOCK ---
        const today = new Date();
        const CURRENT_YEAR = today.getFullYear(); 
        const MONTH_NAMES_SHORT = ["Jan", "Fev", "Mar", "Abr", "Mai", "Jun", "Jul", "Ago", "Set", "Out", "Nov", "Dez"];
        const MEDIA_GASTO_IDEAL = 3000;

        // Fun√ß√µes auxiliares (Mocks para seu c√≥digo rodar sem depend√™ncias externas)
        function formatCurrency(value) {
            if (value === null || typeof value === 'undefined') return '0.00';
            // Usa Math.abs para ignorar sinais ao formatar (sua fun√ß√£o de dados j√° lida com o sinal)
            return Math.abs(value).toFixed(2).replace('.', ',');
        }
        function capitalize(s) {
            if (typeof s !== 'string') return '';
            return s.charAt(0).toUpperCase() + s.slice(1);
        }

        // Dados MOCK: Simulam despesas de v√°rios meses
        const rawData = [
            // Dezembro 2024 (Base: 2500)
            { mes: 12, ano: 2024, valor: 1500, status: 'pago', recorrencia: 'mensal', categoria: 'aluguel' },
            { mes: 12, ano: 2024, valor: 1000, status: 'pago', recorrencia: 'mensal', categoria: 'alimentacao' },
            // Janeiro 2025 (Total: 3000 -> Aumento de 20%)
            { mes: 1, ano: 2025, valor: 2000, status: 'pago', recorrencia: 'mensal', categoria: 'aluguel' },
            { mes: 1, ano: 2025, valor: 1000, status: 'pago', recorrencia: 'mensal', categoria: 'alimentacao' },
            // Fevereiro 2025 (Total: 4000 -> Aumento de 33.3% - DEVE MOSTRAR üî∫)
            { mes: 2, ano: 2025, valor: 2000, status: 'pago', recorrencia: 'mensal', categoria: 'aluguel' },
            { mes: 2, ano: 2025, valor: 1500, status: 'pago', recorrencia: 'mensal', categoria: 'alimentacao' },
            { mes: 2, ano: 2025, valor: 500, status: 'pendente', recorrencia: 'mensal', categoria: 'internet' }, // Item Pendente!
            // Mar√ßo 2025 (Total: 2500 -> Queda de 37.5% - DEVE MOSTRAR üîª)
            { mes: 3, ano: 2025, valor: 1000, status: 'pago', recorrencia: 'mensal', categoria: 'aluguel' },
            { mes: 3, ano: 2025, valor: 1500, status: 'pago', recorrencia: 'mensal', categoria: 'transporte' },
        ];

        // Dados de Receitas MOCK
        const rawRevenues = [
            { mes: 12, ano: 2024, valor: 4000, status: 'recebido' },
            { mes: 1, ano: 2025, valor: 4500, status: 'recebido' },
            { mes: 2, ano: 2025, valor: 5000, status: 'recebido' },
            { mes: 3, ano: 2025, valor: 4000, status: 'recebido' },
        ];
        
        // --- L√ìGICA DE RECEITA (Simula o alinhamento com os meses de gasto) ---

        function calculateMonthlyRevenueTotals(revenues, dataGastosMeses) {
            const monthlyTotalsMap = {};
            revenues.forEach(r => {
                const mesChave = `${r.ano || CURRENT_YEAR}-${String(r.mes).padStart(2, '0')}`;
                if (String(r.status || '').toLowerCase().trim() === 'recebido') {
                    monthlyTotalsMap[mesChave] = (monthlyTotalsMap[mesChave] || 0) + r.valor;
                }
            });
            // Alinha o array de receitas com a ordem de meses dos gastos
            return dataGastosMeses.map(mesChave => monthlyTotalsMap[mesChave] || 0);
        }


        // ===================================
        // SUA FUN√á√ÉO DE DADOS INTEGRADA
        // ===================================

        /**
         * Processa rawData e rawRevenues para obter totais mensais, status de pagamento, 
         * varia√ß√µes percentuais e tooltips detalhados para o gr√°fico de evolu√ß√£o.
         * * @returns {object} Dados formatados para o Plotly.
         */
        function getMonthlyExpenseComparisonData() {
            try {
                // 1. Inicializa√ß√µes
                const monthlyTotals = {}; // Total Projetado
                const monthlyCategoryDetails = {}; // Detalhes por categoria para an√°lise de varia√ß√£o
                const expensesByMonth = {}; // Lista de despesas por m√™s

                if (!rawData || !Array.isArray(rawData)) {
                    console.error("ERRO: rawData n√£o est√° definida ou n√£o √© um array.");
                    return { meses: [], gastos: [], gastosPagos: [], tooltips: [], pendingLists: [], percentDiffs: [] };
                }

                rawData.forEach(d => {
                    if (typeof d.valor !== 'number' || isNaN(d.valor) || d.valor <= 0) {
                        return; // Ignora itens sem valor ou valor negativo/zero
                    }
                    
                    const ano = d.ano || CURRENT_YEAR; 
                    const mesChave = `${ano}-${String(d.mes).padStart(2, '0')}`;
                    
                    // Exclui recorr√™ncia anual (ajuste conforme sua regra de neg√≥cio)
                    const recurrence = String(d.recorrencia || '').toLowerCase().trim();
                    if (recurrence === 'anual') return;

                    // Calcula total Projetado
                    monthlyTotals[mesChave] = (monthlyTotals[mesChave] || 0) + d.valor;

                    // Adiciona a despesa ao m√™s (para calcular pago vs. pendente)
                    if (!expensesByMonth[mesChave]) {
                        expensesByMonth[mesChave] = [];
                    }
                    expensesByMonth[mesChave].push(d); 

                    // Agrupa por categoria (para an√°lise de varia√ß√£o)
                    if (!monthlyCategoryDetails[mesChave]) {
                        monthlyCategoryDetails[mesChave] = {};
                    }
                    monthlyCategoryDetails[mesChave][d.categoria] = (monthlyCategoryDetails[mesChave][d.categoria] || 0) + d.valor;
                });

                // 2. Classifica os meses (YYYY-MM)
                const sortedKeys = Object.keys(monthlyTotals).sort();
            
                const result = {
                    meses: [],
                    gastos: [], // Total Projetado (Linha Vermelha)
                    gastosPagos: [], // Total Pago (Linha Verde Pontilhada)
                    tooltips: [], // HTML para o hover do Projetado
                    pendingLists: [], // HTML para o hover do Pago (lista de pendentes)
                    percentDiffs: [] // Array das varia√ß√µes para as anota√ß√µes
                };

                let previousMonthTotal = 0;

                for (let i = 0; i < sortedKeys.length; i++) {
                    const mesChave = sortedKeys[i];
                    const currentTotal = monthlyTotals[mesChave]; 
                    let currentPaidTotal = 0;

                    const expensesOfMonth = expensesByMonth[mesChave] || [];
                    let pendingItemsList = []; 
                    let percentDiff = 0;

                    // Itera para calcular Pago e listar Pendentes
                    expensesOfMonth.forEach(d => {
                        if (d.status && d.status.toLowerCase() === 'pago') {
                            currentPaidTotal += d.valor;
                        } else {
                            const formattedValue = formatCurrency(d.valor); 
                            pendingItemsList.push(`‚Ä¢ ${capitalize(d.categoria)} (R$ ${formattedValue})`);
                        }
                    });
                    
                    // --- L√≥gica de c√°lculo de diffExplanation (Varia√ß√£o com M√™s Anterior) ---
                    
                    let diffExplanation = 'Primeiro m√™s com dados registrados.';
                    
                    if (i > 0) {
                        const previousMesChave = sortedKeys[i - 1];

                        if (previousMonthTotal > 0) {
                            // C√°lculo da diferen√ßa percentual
                            percentDiff = ((currentTotal - previousMonthTotal) / previousMonthTotal) * 100;
                            
                            // --- An√°lise Detalhada da Diferen√ßa por Categoria ---
                            const prevCats = monthlyCategoryDetails[previousMesChave] || {};
                            const currCats = monthlyCategoryDetails[mesChave] || {};
                            
                            const categoryDifferences = {};
                            const allCategories = new Set([...Object.keys(prevCats), ...Object.keys(currCats)]);
                            
                            allCategories.forEach(cat => {
                                // Diferen√ßa: Categoria Atual - Categoria Anterior
                                const diff = (currCats[cat] || 0) - (prevCats[cat] || 0);
                                if (Math.abs(diff) > 0.01) {
                                    categoryDifferences[cat] = diff;
                                }
                            });

                            // Pega os 3 principais contribuintes em valor absoluto
                            const sortedDiffs = Object.entries(categoryDifferences)
                                .sort(([, a], [, b]) => Math.abs(b) - Math.abs(a))
                                .slice(0, 3); 

                            let changeType = percentDiff >= 0 ? 'aumento' : 'redu√ß√£o';
                            let diffText = '';

                            if (Math.abs(percentDiff) < 0.1) {
                                diffExplanation = 'Sem varia√ß√£o significativa.';
                            } else {
                                diffText = `Varia√ß√£o: <b>${percentDiff.toFixed(2)}%</b> (${changeType} em rela√ß√£o ao m√™s anterior).<br><br>Principais contribui√ß√µes:<br>`;
                                
                                if(sortedDiffs.length > 0) {
                                    sortedDiffs.forEach(([cat, diff]) => {
                                        const sign = diff >= 0 ? '+' : ''; 
                                        const action = diff >= 0 ? 'aumento' : 'redu√ß√£o';
                                        
                                        diffText += `‚Ä¢ ${capitalize(cat)}: ${sign}R$ ${formatCurrency(diff)} (${action})<br>`;
                                    });
                                } else {
                                    diffText += 'Ajustes pequenos em m√∫ltiplas categorias.';
                                }
                                
                                diffExplanation = diffText;
                            }
                        } else if (currentTotal > 0) {
                            diffExplanation = 'Gasto registrado. M√™s anterior zerado.';
                        } else {
                            diffExplanation = 'Sem varia√ß√£o.';
                        }
                    }
                    
                    // Armazena os resultados
                    result.meses.push(mesChave);
                    result.gastos.push(currentTotal);
                    result.tooltips.push(diffExplanation);
                    result.gastosPagos.push(currentPaidTotal);
                    result.percentDiffs.push(percentDiff);

                    // Formata a lista de pendentes para o tooltip
                    if (pendingItemsList.length > 0) {
                        // O Plotly espera uma string √∫nica no customdata, que usamos <br> para formatar no hover
                        result.pendingLists.push(`<b>Total Pendente: R$ ${formatCurrency(currentTotal - currentPaidTotal)}</b><br><br>${pendingItemsList.join('<br>')}`);
                    } else {
                        result.pendingLists.push('Nenhum item pendente.');
                    }

                    previousMonthTotal = currentTotal;
                }

                console.log("‚úÖ DEBUG: Varia√ß√µes de Porcentagem Geradas:", result.percentDiffs.map(d => d.toFixed(1) + '%'));
                return result;
            } catch (error) {
                console.error("‚ùå ERRO CR√çTICO na getMonthlyExpenseComparisonData:", error);
                return { meses: [], gastos: [], gastosPagos: [], tooltips: [], pendingLists: [], percentDiffs: [] };
            }
        }


        // ===================================
        // FUN√á√ÉO DE RENDERIZA√á√ÉO DO GR√ÅFICO (PLOTLY)
        // ===================================

        function renderMonthlyEvolutionChart() {
            
            const graficoDiv = document.getElementById('grafico-evolucao-mensal');

            if (!graficoDiv) {
                return;
            }

            try {
                const dataGastos = getMonthlyExpenseComparisonData();
                
                const { meses: keys, gastos: monthlyTotalTotals, gastosPagos: monthlyPaidTotals, percentDiffs } = dataGastos;

                // Checagem de dados vazios
                if (monthlyTotalTotals.length === 0 || monthlyTotalTotals.every(total => total === 0)) {
                    graficoDiv.innerHTML = '<p style="text-align: center; color: #6c757d;">Dados de gastos insuficientes para gerar a evolu√ß√£o mensal.</p>';
                    return;
                }
                
                // 1. R√ìTULOS (X-AXIS)
                const labels = keys.map(key => {
                    const monthIndex = parseInt(key.substring(5, 7)) - 1; 
                    const year = key.substring(0, 4);
                    return `${MONTH_NAMES_SHORT[monthIndex]} ${year.substring(2)}`;
                });

                // 2. M√âDIA REAL DE GASTO
                const gastosReais = monthlyTotalTotals.filter(g => g > 0);
                const totalGasto = gastosReais.reduce((a, b) => a + b, 0);
                const mediaGasto = gastosReais.length > 0 ? totalGasto / gastosReais.length : 0;
                
                // 3. RECEITA E SALDO L√çQUIDO
                const monthlyRevenueTotals = calculateMonthlyRevenueTotals(rawRevenues, keys);

                const monthlyNetIncome = monthlyRevenueTotals.map((revenue, index) => {
                    const expense = monthlyTotalTotals[index] || 0;
                    return revenue - expense; 
                });

                const pendingItemsCustomData = dataGastos.pendingLists.map(list => [list]);
                const netIncomeCustomData = monthlyNetIncome.map(value => [value]);


                // 4. ANOTA√á√ïES DE VARIA√á√ÉO (üî∫/üîª)
                const annotations = [];
                const THRESHOLD = 15; // 15% de varia√ß√£o

                percentDiffs.forEach((diff, index) => {
                    if (index === 0) return; 

                    const absDiff = Math.abs(diff);
                    
                    if (absDiff >= THRESHOLD) {
                        const isIncrease = diff > 0;
                        const symbol = isIncrease ? 'üî∫' : 'üîª';
                        const color = isIncrease ? '#dc3545' : '#28a745';

                        // Posi√ß√£o Y ajustada (no referencial 'paper' - 0 a 1 - abaixo do gr√°fico)
                        annotations.push({
                            xref: 'x',
                            yref: 'paper',
                            x: labels[index],
                            y: -0.15, 
                            text: `${symbol} ${absDiff.toFixed(1)}%`,
                            showarrow: false,
                            font: {
                                color: color,
                                size: 10,
                                weight: 'bold'
                            }
                        });
                    }
                });

                // 5. LAYOUT E SHAPES (Linhas de Meta e M√©dia)
                const layout = {
                    annotations: annotations,
            
                    legend: {
                        orientation: 'h',
                        xanchor: 'center',
                        x: 0.5,
                        yanchor: 'top',
                        y: -0.25 
                    },
                    
                    shapes: [
                        // Linha da Meta (MEDIA_GASTO_IDEAL)
                        { type: 'line', xref: 'paper', yref: 'y', x0: 0, y0: MEDIA_GASTO_IDEAL, x1: 1, y1: MEDIA_GASTO_IDEAL, line: { color: 'orange', width: 2, dash: 'dashdot' } },
                        // Linha da M√©dia Real (mediaGasto)
                        { type: 'line', xref: 'paper', yref: 'y', x0: 0, y0: mediaGasto, x1: 1, y1: mediaGasto, line: { color: '#6f42c1', width: 1, dash: 'dash' } }
                    ],
                    xaxis: { tickmode: 'array', tickvals: labels, ticktext: labels },
                    yaxis: { title: 'Valor (R$)', rangemode: 'tozero' },
                    margin: { t: 40, l: 40, r: 20, b: 150 }, // Margem inferior aumentada para anota√ß√µes
                    hovermode: 'closest'
                };

                // 6. TRACES (As Linhas do Gr√°fico)

                // Trace 1: Gasto Total Projetado (Vermelho)
                const traceTotal = { 
                    x: labels, y: monthlyTotalTotals, mode: 'lines+markers', type: 'scatter', name: 'Gasto Projetado', 
                    line: { color: '#dc3545', width: 3 }, marker: { size: 8, color: '#dc3545', line: { width: 1, color: 'white' } }, 
                    hoverinfo: 'text', text: dataGastos.tooltips, 
                    hovertemplate: '<b>M√™s/Ano:</b> %{x}<br><b>Gasto Projetado:</b> %{y:$.2f}<br><br>%{text}<extra></extra>' 
                };
                
                // Trace 2: Gasto Total Pago (Verde)
                const tracePaid = { 
                    x: labels, y: monthlyPaidTotals, mode: 'lines+markers', type: 'scatter', name: 'Gasto Pago', 
                    line: { color: '#28a745', width: 2, dash: 'dot' }, marker: { size: 8, color: '#28a745', line: { width: 1, color: 'white' } }, 
                    customdata: pendingItemsCustomData, 
                    hovertemplate: '<b>%{x}</b><br>Gasto Pago: R$ %{y:,.2f}<br><br>%{customdata[0]}<extra></extra>' 
                };

                // Trace 3: Linha de Receita Total Recebida (Azul)
                const traceRevenue = { 
                    x: labels, y: monthlyRevenueTotals, mode: 'lines+markers', type: 'scatter', name: 'Receita Recebida', 
                    line: { color: '#007bff', width: 2, dash: 'dash' }, customdata: netIncomeCustomData, 
                    hovertemplate: '<b>Receita:</b> R$ %{y:,.2f}<br><b>Saldo L√≠quido:</b> R$ %{customdata[0]:,.2f}<extra>Receita Total</extra>' 
                };

                // Trace DUMMY: Apenas para aparecer a legenda da linha de meta
                const traceGoal = { x: [labels[0]], y: [MEDIA_GASTO_IDEAL], mode: 'lines', type: 'scatter', name: `Meta Ideal (R$ ${formatCurrency(MEDIA_GASTO_IDEAL)})`, line: { color: 'orange', width: 1, dash: 'dashdot' }, marker: { size: 0 }, showlegend: true, hoverinfo: 'none' };

                Plotly.newPlot(graficoDiv, [traceTotal, tracePaid, traceRevenue, traceGoal], layout, { displayModeBar: false, responsive: true });

            } catch (error) {
                console.error("‚ùå ERRO ao renderizar o gr√°fico de evolu√ß√£o mensal:", error);
                graficoDiv.innerHTML = `<p style="text-align: center; color: #dc3545;">Erro ao gerar o gr√°fico: ${error.message}</p>`;
            }

            // Garante que o gr√°fico seja responsivo
            window.onresize = function() {
                if (typeof Plotly !== 'undefined') {
                    Plotly.relayout('grafico-evolucao-mensal', { 'autosize': true });
                }
            };
        }

        // Inicia a renderiza√ß√£o do gr√°fico ap√≥s o carregamento da p√°gina
        document.addEventListener('DOMContentLoaded', renderMonthlyEvolutionChart);

    </script>
</body>
</html>
